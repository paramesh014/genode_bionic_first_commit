/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#ifndef _PMAP_PROT_H_RPCGEN
#define _PMAP_PROT_H_RPCGEN

#include <rpc/rpc.h>


#ifdef __cplusplus
extern "C" {
#endif

/*
 * Sun RPC is a product of Sun Microsystems, Inc. and is provided for
 * unrestricted use provided that this legend is included on all tape
 * media and as a part of the software program in whole or part.  Users
 * may copy or modify Sun RPC without charge, but are not authorized
 * to license or distribute it to anyone else except as part of a product or
 * program developed by the user.
 *
 * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE
 * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.
 *
 * Sun RPC is provided with no support and without any obligation on the
 * part of Sun Microsystems, Inc. to assist in its use, correction,
 * modification or enhancement.
 *
 * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE
 * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC
 * OR ANY PART THEREOF.
 *
 * In no event will Sun Microsystems, Inc. be liable for any lost revenue
 * or profits or other special, indirect and consequential damages, even if
 * Sun has been advised of the possibility of such damages.
 *
 * Sun Microsystems, Inc.
 * 2550 Garcia Avenue
 * Mountain View, California  94043
 */
/*
 * Copyright (c) 1984,1989 by Sun Microsystems, Inc.
 */
/* from pmap_prot.x */

#pragma ident "@(#)pmap_prot.x	1.6	94/04/29 SMI"
#include <sys/cdefs.h>
__FBSDID("$FreeBSD: release/8.2.0/include/rpcsvc/pmap_prot.x 114629 2003-05-04 02:51:42Z obrien $");

#ifndef _KERNEL

/*
 * Protocol for the local binder service, or pmap.
 *
 * Copyright (C) 1984, Sun Microsystems, Inc.
 *
 * The following procedures are supported by the protocol:
 *
 * PMAPPROC_NULL() returns ()
 * 	takes nothing, returns nothing
 *
 * PMAPPROC_SET(struct pmap) returns (bool_t)
 * 	TRUE is success, FALSE is failure.  Registers the tuple
 *	[prog, vers, prot, port].
 *
 * PMAPPROC_UNSET(struct pmap) returns (bool_t)
 *	TRUE is success, FALSE is failure.  Un-registers pair
 *	[prog, vers].  prot and port are ignored.
 *
 * PMAPPROC_GETPORT(struct pmap) returns (long unsigned).
 *	0 is failure.  Otherwise returns the port number where the pair
 *	[prog, vers] is registered.  It may lie!
 *
 * PMAPPROC_DUMP() RETURNS (struct pmaplist_ptr)
 *
 * PMAPPROC_CALLIT(unsigned, unsigned, unsigned, string<>)
 * 	RETURNS (port, string<>);
 * usage: encapsulatedresults = PMAPPROC_CALLIT(prog, vers, proc,
 *						encapsulatedargs);
 * 	Calls the procedure on the local machine.  If it is not registered,
 *	this procedure is quite; ie it does not return error information!!!
 *	This procedure only is supported on rpc/udp and calls via
 *	rpc/udp.  This routine only passes null authentication parameters.
 *	This file has no interface to xdr routines for PMAPPROC_CALLIT.
 *
 * The service supports remote procedure calls on udp/ip or tcp/ip socket 111.
 */

#define PMAPPORT 111


/*
 * A mapping of (program, version, protocol) to port number
 */

struct pmap {
	u_long pm_prog;
	u_long pm_vers;
	u_long pm_prot;
	u_long pm_port;
};
typedef struct pmap pmap;

typedef pmap PMAP;


/*
 * Supported values for the "prot" field
 */

#define PMAP_IPPROTO_TCP 6
#define PMAP_IPPROTO_UDP 17


/*
 * A list of mappings
 *
 * Below are two definitions for the pmaplist structure.  This is done because
 * xdr_pmaplist() is specified to take a struct pmaplist **, rather than a
 * struct pmaplist * that rpcgen would produce.  One version of the pmaplist
 * structure (actually called pm__list) is used with rpcgen, and the other is
 * defined only in the header file for compatibility with the specified
 * interface.
 */

struct pm__list {
	pmap pml_map;
	struct pm__list *pml_next;
};
typedef struct pm__list pm__list;

typedef pm__list *pmaplist_ptr;

typedef struct pm__list pmaplist;
typedef struct pm__list PMAPLIST;

#ifndef __cplusplus
struct pmaplist {
 PMAP pml_map;
 struct pmaplist *pml_next;
};
#endif

#ifdef __cplusplus
extern "C" {
#endif
extern bool_t xdr_pmaplist(XDR *, pmaplist**);
#ifdef __cplusplus
}
#endif


/*
 * Arguments to callit
 */

struct rmtcallargs {
	u_long prog;
	u_long vers;
	u_long proc;
	struct {
		u_int args_len;
		char *args_val;
	} args;
};
typedef struct rmtcallargs rmtcallargs;

/*
 * Client-side only representation of rmtcallargs structure.
 *
 * The routine that XDRs the rmtcallargs structure must deal with the
 * opaque arguments in the "args" structure.  xdr_rmtcall_args() needs to be
 * passed the XDR routine that knows the args' structure.  This routine
 * doesn't need to go over-the-wire (and it wouldn't make sense anyway) since
 * the application being called knows the args structure already.  So we use a
 * different "XDR" structure on the client side, p_rmtcallargs, which includes
 * the args' XDR routine.
 */
struct p_rmtcallargs {
 u_long prog;
 u_long vers;
 u_long proc;
 struct {
 u_int args_len;
 char *args_val;
 } args;
 xdrproc_t xdr_args; /* encodes args */
};



/*
 * Results of callit
 */

struct rmtcallres {
	u_long port;
	struct {
		u_int res_len;
		char *res_val;
	} res;
};
typedef struct rmtcallres rmtcallres;

/*
 * Client-side only representation of rmtcallres structure.
 */
struct p_rmtcallres {
 u_long port;
 struct {
 u_int res_len;
 char *res_val;
 } res;
 xdrproc_t xdr_res; /* decodes res */
};


#define PMAPVERS_PROTO ((u_long)2)
#define PMAPVERS_ORIG ((u_long)1)

#else /* ndef _KERNEL */

#include <rpc/pmap_rmt.h>

#ifdef __cplusplus
extern "C" {
#endif

#define PMAPPORT 111

struct pmap {
 long unsigned pm_prog;
 long unsigned pm_vers;
 long unsigned pm_prot;
 long unsigned pm_port;
};
typedef struct pmap PMAP;
extern bool_t xdr_pmap (XDR *, struct pmap *);

struct pmaplist {
 struct pmap pml_map;
 struct pmaplist *pml_next;
};
typedef struct pmaplist PMAPLIST;
typedef struct pmaplist *pmaplist_ptr;


#ifdef __cplusplus
}
#endif

#endif /* ndef _KERNEL */

#define PMAPPROG 100000
#define PMAPVERS 2

#if defined(__STDC__) || defined(__cplusplus)
#define PMAPPROC_NULL 0
extern  void * pmapproc_null_2(void *, CLIENT *);
extern  void * pmapproc_null_2_svc(void *, struct svc_req *);
#define PMAPPROC_SET 1
extern  bool_t * pmapproc_set_2(pmap *, CLIENT *);
extern  bool_t * pmapproc_set_2_svc(pmap *, struct svc_req *);
#define PMAPPROC_UNSET 2
extern  bool_t * pmapproc_unset_2(pmap *, CLIENT *);
extern  bool_t * pmapproc_unset_2_svc(pmap *, struct svc_req *);
#define PMAPPROC_GETPORT 3
extern  u_long * pmapproc_getport_2(pmap *, CLIENT *);
extern  u_long * pmapproc_getport_2_svc(pmap *, struct svc_req *);
#define PMAPPROC_DUMP 4
extern  pmaplist_ptr * pmapproc_dump_2(void *, CLIENT *);
extern  pmaplist_ptr * pmapproc_dump_2_svc(void *, struct svc_req *);
#define PMAPPROC_CALLIT 5
extern  rmtcallres * pmapproc_callit_2(rmtcallargs *, CLIENT *);
extern  rmtcallres * pmapproc_callit_2_svc(rmtcallargs *, struct svc_req *);
extern int pmapprog_2_freeresult (SVCXPRT *, xdrproc_t, caddr_t);

#else /* K&R C */
#define PMAPPROC_NULL 0
extern  void * pmapproc_null_2();
extern  void * pmapproc_null_2_svc();
#define PMAPPROC_SET 1
extern  bool_t * pmapproc_set_2();
extern  bool_t * pmapproc_set_2_svc();
#define PMAPPROC_UNSET 2
extern  bool_t * pmapproc_unset_2();
extern  bool_t * pmapproc_unset_2_svc();
#define PMAPPROC_GETPORT 3
extern  u_long * pmapproc_getport_2();
extern  u_long * pmapproc_getport_2_svc();
#define PMAPPROC_DUMP 4
extern  pmaplist_ptr * pmapproc_dump_2();
extern  pmaplist_ptr * pmapproc_dump_2_svc();
#define PMAPPROC_CALLIT 5
extern  rmtcallres * pmapproc_callit_2();
extern  rmtcallres * pmapproc_callit_2_svc();
extern int pmapprog_2_freeresult ();
#endif /* K&R C */

/* the xdr functions */

#if defined(__STDC__) || defined(__cplusplus)
extern  bool_t xdr_pmap (XDR *, pmap*);
extern  bool_t xdr_pm__list (XDR *, pm__list*);
extern  bool_t xdr_pmaplist_ptr (XDR *, pmaplist_ptr*);
extern  bool_t xdr_rmtcallargs (XDR *, rmtcallargs*);
extern  bool_t xdr_rmtcallres (XDR *, rmtcallres*);

#else /* K&R C */
extern bool_t xdr_pmap ();
extern bool_t xdr_pm__list ();
extern bool_t xdr_pmaplist_ptr ();
extern bool_t xdr_rmtcallargs ();
extern bool_t xdr_rmtcallres ();

#endif /* K&R C */

#ifdef __cplusplus
}
#endif

#endif /* !_PMAP_PROT_H_RPCGEN */
